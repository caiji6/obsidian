# 👌Mysql死锁常见解决方案？

MySQL中的死锁是指两个或多个事务相互等待对方持有的锁，从而导致这些事务无法继续执行。死锁是并发控制中的一个常见问题，特别是在高并发环境下。

### 1.**分析和优化SQL语句**
+ **减少锁的持有时间**：优化SQL语句，使其执行时间更短，从而减少锁的持有时间，降低死锁发生的概率。
+ **避免大事务**：将大事务拆分为多个小事务，减少每个事务持有锁的时间。
+ **索引优化**：确保查询使用了合适的索引，减少全表扫描，从而减少锁冲突。

### 2.**调整事务的顺序**
+ **统一访问顺序**：确保所有事务以相同的顺序访问资源。例如，如果多个事务都需要访问表A和表B，确保所有事务都先访问表A，再访问表B。
+ **减少循环等待**：通过调整事务的执行顺序，避免事务之间形成循环等待。

### 3.**使用合适的隔离级别**
+ **降低隔离级别**：在某些情况下，可以考虑使用较低的隔离级别（如READ COMMITTED）来减少锁冲突。但需要权衡数据一致性和并发性能。
+ **使用锁机制**：在某些情况下，可以显式使用LOCK IN SHARE MODE或FOR UPDATE来控制锁的粒度和范围。

### 4.**合理使用索引**
+ **覆盖索引**：使用覆盖索引（covering index）来减少锁的争用。例如，如果查询只需要访问索引列，可以避免访问数据行，从而减少锁冲突。
+ **避免索引缺失**：确保查询使用了合适的索引，避免全表扫描导致的大量锁争用。

### 5.**监控和分析**
+ **启用死锁日志**：在MySQL配置中启用死锁日志，记录死锁信息以便分析。

```plain
[mysqld]
innodb_print_all_deadlocks = 1
```

+ **分析死锁日志**：通过分析死锁日志，找出导致死锁的SQL语句和事务，进行针对性的优化。

### 6.**重试机制**
+ **自动重试**：在应用程序中实现自动重试机制，当捕获到死锁错误（如ER_LOCK_DEADLOCK）时，自动重试事务。

```plain
BEGIN;
-- 事务操作
COMMIT;
-- 捕获死锁错误并重试
```

### 7.**锁等待超时**
+ **设置合理的锁等待超时**：通过设置合理的锁等待超时参数（如innodb_lock_wait_timeout），避免长时间等待锁，从而减少死锁影响。

```plain
SET innodb_lock_wait_timeout = 10;
```

### 8.**分区表**
+ **使用分区表**：在某些情况下，可以使用分区表来减少锁冲突。通过将数据分区到不同的物理文件，可以减少不同事务之间的锁冲突。

### 9.**行级锁**
+ **使用行级锁**：尽量使用行级锁而不是表级锁，以减少锁的粒度，从而减少锁冲突的概率。

### 10.**避免热点更新**
+ **分散更新压力**：避免对同一行或同一页的频繁更新，可以通过分散更新压力来减少锁冲突。例如，可以使用分区或分表的方式。



> 原文: <https://www.yuque.com/jingdianjichi/xyxdsi/aa3ru8htlcfdmqu8>