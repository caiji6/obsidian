# ğŸ‘Œå¯é‡å…¥é”å®ç°åŸç†

# é¢˜ç›®è¯¦ç»†ç­”æ¡ˆ
å¯é‡å…¥é”ï¼ˆReentrant Lockï¼‰çš„å®ç°åŸç†æ¶‰åŠåˆ°é”çš„è®¡æ•°å™¨å’Œçº¿ç¨‹æ‹¥æœ‰è€…çš„ç®¡ç†ã€‚åœ¨ Java ä¸­ï¼ŒReentrantLockæ˜¯é€šè¿‡java.util.concurrent.locks.AbstractQueuedSynchronizerï¼ˆAQSï¼‰æ¥å®ç°çš„ã€‚

## åŸºæœ¬åŸç†
å¯é‡å…¥é”çš„åŸºæœ¬åŸç†æ˜¯ï¼š

1. **é”è®¡æ•°å™¨**ï¼šæ¯ä¸ªçº¿ç¨‹å¯¹é”çš„è·å–éƒ½ä¼šå¢åŠ é”çš„è®¡æ•°å™¨ï¼Œé‡Šæ”¾é”åˆ™ä¼šå‡å°‘é”çš„è®¡æ•°å™¨ã€‚è®¡æ•°å™¨ä¸ºé›¶æ—¶ï¼Œé”æ‰çœŸæ­£è¢«é‡Šæ”¾ã€‚
2. **çº¿ç¨‹æ‹¥æœ‰è€…**ï¼šé”è®°å½•å“ªä¸ªçº¿ç¨‹æŒæœ‰å®ƒï¼Œå¹¶ä¸”åªæœ‰æŒæœ‰é”çš„çº¿ç¨‹æ‰èƒ½é‡æ–°è·å–å®ƒã€‚

## ReentrantLockçš„å®ç°
ReentrantLocké€šè¿‡å†…éƒ¨ç±»Syncæ¥å®ç°é”çš„å…·ä½“æœºåˆ¶ï¼ŒSyncç»§æ‰¿è‡ªAbstractQueuedSynchronizerï¼ˆAQSï¼‰ã€‚AQS æä¾›äº†ä¸€å¥—æ¡†æ¶ï¼Œç”¨äºå®ç°ä¾èµ– FIFO é˜Ÿåˆ—çš„åŒæ­¥å™¨ã€‚

### ä¸»è¦æˆå‘˜å˜é‡å’Œæ–¹æ³•
1. **çŠ¶æ€å˜é‡**ï¼šAQS ä½¿ç”¨ä¸€ä¸ªvolatileçš„intå˜é‡stateæ¥è¡¨ç¤ºé”çš„çŠ¶æ€ã€‚å¯¹äºå¯é‡å…¥é”ï¼Œstateè¡¨ç¤ºé”çš„è®¡æ•°å™¨ã€‚
2. **å½“å‰æŒæœ‰é”çš„çº¿ç¨‹**ï¼šä½¿ç”¨Threadå˜é‡exclusiveOwnerThreadæ¥è®°å½•å½“å‰æŒæœ‰é”çš„çº¿ç¨‹ã€‚

### è·å–é”
å½“çº¿ç¨‹å°è¯•è·å–é”æ—¶ï¼Œä¼šè°ƒç”¨ReentrantLock.lock()æ–¹æ³•ï¼š

```plain
public void lock() {
    sync.lock();
}
```

syncæ˜¯ReentrantLockçš„å†…éƒ¨ç±»Syncçš„å®ä¾‹ï¼ŒSyncæœ‰ä¸¤ä¸ªå…·ä½“å®ç°ï¼šNonfairSyncå’ŒFairSyncã€‚è¿™ä¸¤ä¸ªå®ç°åˆ†åˆ«ç”¨äºéå…¬å¹³é”å’Œå…¬å¹³é”ã€‚

```plain
abstract static class Sync extends AbstractQueuedSynchronizer {
    abstract void lock();
}

static final class NonfairSync extends Sync {
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
}

static final class FairSync extends Sync {
    final void lock() {
        acquire(1);
    }
}
```

NonfairSyncå°è¯•ç›´æ¥è·å–é”ï¼Œå¦‚æœå¤±è´¥åˆ™è°ƒç”¨acquire(1)æ–¹æ³•ã€‚FairSyncç›´æ¥è°ƒç”¨acquire(1)æ–¹æ³•ã€‚

### acquireæ–¹æ³•
acquireæ–¹æ³•æ˜¯ AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼Œç”¨äºè·å–é”ï¼š

```plain
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

tryAcquireæ˜¯Syncçš„å…·ä½“å®ç°ï¼š

```plain
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

å¦‚æœstateä¸º 0ï¼Œè¡¨ç¤ºé”æœªè¢«æŒæœ‰ï¼Œå°è¯•é€šè¿‡compareAndSetStateè·å–é”ï¼Œå¹¶è®¾ç½®å½“å‰çº¿ç¨‹ä¸ºé”çš„æ‹¥æœ‰è€…ã€‚

å¦‚æœstateä¸ä¸º 0 ä¸”å½“å‰çº¿ç¨‹æ˜¯é”çš„æ‹¥æœ‰è€…ï¼Œåˆ™å¢åŠ é”çš„è®¡æ•°å™¨ã€‚

### é‡Šæ”¾é”
å½“çº¿ç¨‹é‡Šæ”¾é”æ—¶ï¼Œä¼šè°ƒç”¨ReentrantLock.unlock()æ–¹æ³•ï¼š

```plain
public void unlock() {
    sync.release(1);
}
```

releaseæ–¹æ³•æ˜¯ AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼Œç”¨äºé‡Šæ”¾é”ï¼š

```plain
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

tryReleaseæ˜¯Syncçš„å…·ä½“å®ç°ï¼š

```plain
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

å‡å°‘é”çš„è®¡æ•°å™¨ã€‚

å¦‚æœè®¡æ•°å™¨ä¸º 0ï¼Œè¡¨ç¤ºé”è¢«å®Œå…¨é‡Šæ”¾ï¼Œæ¸…é™¤é”çš„æ‹¥æœ‰è€…ã€‚



> åŸæ–‡: <https://www.yuque.com/jingdianjichi/xyxdsi/nc7f3pg4gg7il5p9>