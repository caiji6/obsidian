[![缓存击穿场景解决.mp4 (25.68MB)](https://gw.alipayobjects.com/mdn/prod_resou/afts/img/A*NNs6TKOR3isAAAAAAAAAAABkARQnAQ)](https://www.yuque.com/docs/176645997?_lake_card=%7B%22status%22%3A%22done%22%2C%22name%22%3A%22%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3.mp4%22%2C%22size%22%3A26924445%2C%22taskId%22%3A%22u65010d70-9f2b-41b5-af15-b9f67e40019%22%2C%22taskType%22%3A%22upload%22%2C%22url%22%3Anull%2C%22cover%22%3Anull%2C%22videoId%22%3A%22inputs%2Fprod%2Fyuque%2F2024%2F29413969%2Fmp4%2F1720371097667-74b8c82e-2512-4c99-8ffb-f46baaf6f350.mp4%22%2C%22download%22%3Afalse%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22gIUHf%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22video%22%7D#gIUHf)# 背景
想到一个缓存击穿的案例，大家应该或多或少听说过社区团购，比如多多买菜。<br />![](https://cdn.nlark.com/yuque/0/2024/png/29413969/1718345102954-71b7e7a5-6abd-42f5-9d91-fbe412e1c2a3.png#averageHue=%23aec96e&clientId=u562b0a17-d043-4&from=paste&height=698&id=u9ba66e3b&originHeight=2340&originWidth=1080&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ufc2b9d44-d033-44bf-b131-1f9940389eb&title=&width=322)<br />点进去一个商品之后，会发现他的模式是当天23点之前购买，第二天16点取货。<br />![](https://cdn.nlark.com/yuque/0/2024/png/29413969/1718345102909-c7ef5b98-210e-45c5-934e-f985f0611a71.png#averageHue=%239cbe57&clientId=u562b0a17-d043-4&from=paste&height=709&id=u0eef23fa&originHeight=2340&originWidth=1080&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1a0437a2-c748-48b8-9da3-59a545faa15&title=&width=327)<br />这个23点的概念，其实比较有意思，每到23点相当于今天卖完结束了，会更新出一批新品，来进行展示，回想刚才的首页商品列表，其实是昨天场次的商品。一旦到了23点会进行品类的刷新。这个时候23点就会进行大量的商品信息查询，假设现在一个热销商品会展示在大部分用户的商品列表里面。但是商品的其中一个信息，比如他的一个标签【最近300人买过】，这个数据没有提前进行数据缓存的预热。此时就会造成在切换商品的一瞬间，大量的请求都来请求这个商品的标签，又没有缓存，就会到数据库，这个就叫缓存击穿。<br />![](https://cdn.nlark.com/yuque/0/2024/png/29413969/1718345102877-eb5737b9-ed39-4c46-8162-a93f86f9e5b5.png#averageHue=%23f5f5f5&clientId=u562b0a17-d043-4&from=paste&id=ub31c59db&originHeight=1174&originWidth=1994&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u4ded19b1-db50-40e2-9de7-c480519a09e&title=)<br />很多小伙伴会说，这个很穿透差不多吧。二者的区别在于，一瞬间请求全部过来，虽然有查询数据库后，放入缓存的逻辑，但是数据库查询和放入缓存是需要时间的，在这之前，请求会全部干到数据库，这叫击穿。没有时间限制，有不存在的数据打到数据库，这叫穿透。
# <br />方案解决
那么如何解决呢？为了避免缓存击穿，可以在数据库返回结果到缓存数据更新这个间隙期间增加分布式锁来解决，当缓存数据更新完成释放分布式锁，在加锁期间所有请求直接返回起到保护数据库的作用，这里特别注意的是对分布式锁要设置合理地过期时间，比如可能这个业务请求在1s内可以完成，那么可以设置5s，在较长的时间内确保可以完成缓存更新操作即可，完成后主动移除分布式锁，所有的分布式锁都要设置合理的过期时间避免产生“死锁”使业务逻辑产生问题。<br />![](https://cdn.nlark.com/yuque/0/2024/png/29413969/1718345102942-74d55089-e899-4a57-970d-b433f94a94a2.png#averageHue=%23f5f5f5&clientId=u562b0a17-d043-4&from=paste&id=ud05d94ed&originHeight=1170&originWidth=1934&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=udd09590b-1a92-48b3-b6c2-fe4b15c866e&title=)

除了分布式锁来控制防止缓存穿透问题的出现，还可以在查询缓存没有时直接将缓存更新成空值，确保其他线程请求后直接返回空值起到保护数据库的作用，之后当前线程查询到数据库数据直接返回更新缓存成真实数据，如果没查到也不进行缓存更新了。

