CMS（Concurrent Mark-Sweep）和 G1（Garbage-First）是两种不同的垃圾收集器，以下是它们之间的主要区别：
### 1. CMS 收集器
#### 概述
CMS 是一种低停顿的垃圾收集器，设计目标是减少应用程序的停顿时间。它适用于对响应时间要求高的应用程序，例如 Web 服务器。
#### 工作原理
CMS 收集器的工作过程主要分为以下几个阶段：

1. **初始标记（Initial Mark）**：标记直接可达的对象，这个阶段需要暂停所有应用线程（Stop-the-world，STW）。
2. **并发标记（Concurrent Mark）**：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。
3. **重新标记（Remark）**：再次暂停所有应用线程，标记在并发标记阶段发生变化的对象。
4. **并发清除（Concurrent Sweep）**：在应用线程运行的同时，清除不可达的对象。
#### 优点

- **低停顿时间**：CMS 尽量减少应用程序的停顿时间，适合对响应时间敏感的应用。
- **并发执行**：大部分工作在应用线程运行的同时进行，减少了 STW 时间。
#### 缺点

- **内存碎片**：CMS 使用标记-清除算法，可能会产生内存碎片，导致内存利用率下降。
- **高 CPU 开销**：并发阶段需要额外的 CPU 资源，可能对系统性能有影响。
- **老年代 GC 频繁**：老年代的垃圾回收频率较高，可能导致频繁的 Full GC。
### 2. G1 收集器
#### 概述
G1 是一种面向服务端应用的垃圾收集器，设计目标是提供可预测的停顿时间，同时具备较高的吞吐量。G1 收集器适用于大内存、多处理器的环境。
#### 工作原理
G1 收集器将堆划分为多个大小相等的区域（Region），每个区域可以作为 Eden、Survivor 或 Old 区。G1 的工作过程包括：

1. **初始标记（Initial Mark）**：标记从根对象直接可达的对象，需要暂停应用线程（STW）。
2. **并发标记（Concurrent Mark）**：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。
3. **最终标记（Final Mark）**：再次暂停应用线程，标记在并发标记阶段发生变化的对象。
4. **筛选回收（Live Data Counting and Cleanup）**：计算每个区域的存活对象数量，并根据回收收益选择要回收的区域。回收过程包括复制存活对象和清理区域。
#### 优点

- **可预测的停顿时间**：G1 能够通过用户指定的停顿时间目标（Pause Time Goal）进行调优，提供可预测的垃圾回收停顿时间。
- **减少内存碎片**：G1 使用标记-复制算法，减少了内存碎片问题。
- **区域化管理**：堆被划分为多个区域，有助于更灵活和高效的内存管理。
#### 缺点

- **复杂性**：G1 的实现和调优相对复杂，需要更多的配置和监控。
- **初始开销**：G1 的初始标记和筛选回收阶段仍然会引起一定的停顿。
### 比较总结
| 特性 | CMS 收集器 | G1 收集器 |
| --- | --- | --- |
| 设计目标 | 低停顿时间 | 可预测的停顿时间，较高吞吐量 |
| 内存管理 | 标记-清除，可能产生碎片 | 标记-复制，减少内存碎片 |
| 并发性 | 并发标记和清除 | 并发标记，区域化回收 |
| 停顿时间 | 较短，但不确定 | 可配置的停顿时间目标 |
| 适用场景 | 对响应时间敏感的应用 | 大内存、多处理器、需要可预测停顿时间的应用 |

### 选择建议

- **CMS 收集器**：适用于对响应时间要求高、内存较小、应用负载相对稳定的场景。
- **G1 收集器**：适用于大内存、多处理器环境，需要可预测停顿时间的应用，特别是那些需要处理大量数据和高并发请求的服务端应用。
